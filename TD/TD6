T' -> Après
T -> Courant


package Pile is
    
    type T_Pile is private;
    
    
--Semantique : Initialise la Pile
--Entrée : Rien
--Sortie : Une Pile
--Preconditions : Rien
--Postconditions : Une pile file {Pyle.sommet = 0}
    procedure init (Pyle : out T_Pile);

--Semantique : Empile une valeur
--Entrée : Un entier
--Sortie : Une Pile avec la valeur empilée
--Preconditions : Pyle.sommet < Capacite
--Postconditions : {Pyle.Data(som)=Fe ^ FP'.som == FP.sommet + 1 }
    procedure empiler (Pyle: in out T_Pile,value : in Integer);

--Semantique : Depile une valeur
--Entrée : Rien
--Sortie : Une Pile depilée
--Preconditions : Pyle.sommet != 0
--Postconditions : Pyle'.som == Pyle.som - 1
    procedure depiler (Pyle: in out T_Pile);

--Semantique : Retourne le sommet de la pile
--Entrée : Rien
--Sortie : Un entier
--Preconditions : Pile non vide
--Postconditions : Pyle.Data(Pyle.sommet) == resultat
    function getSommet(Pyle: in T_Pile) return Integer;

--Semantique : Retourne si la pile est vide
--Entrée : Rien
--Sortie : Un booléen
--Preconditions : Rien
--Postconditions : resultat == (Pyle.sommet == 0)
    function isEmpty(Pyle: in T_Pile) return Boolean;

--Semantique : Retourne si deux piles sont égales
--Entrée : Deux piles
--Sortie : Un booléen
--Preconditions : Pile1.sommet == Pile2.sommet
--Postconditions : Rien
    function '=' (P1:in T_Pile,P2:in T_Pile) return Boolean;
    

private

Capacite:Integer := 50;
type Donne_Pile is array (Capacite) of Integer;
type T_Pile is
        record
            Data : Donne_Pile
            Sommet : Integer
        end record


end T_Pile;









with Pile
use Pile
procedure test_pile is
    unePile : T_Pile

debut
    Init(unePile)

    Empiler(unePile,5)
    Empiler(unePile,3)
    Empiler(unePile,9)

    Pragma(getSommet(unePile)==9)

    Depiler(unePile)
    Depiler(unePile)
    Depiler(unePile)

    Pragma(isEmpty(unePile))
fin


package body T_Pile is 

    procedure initialiser(Pile : out T_Pile) is
        begin
            Pile.Data := new array (T_Pile.Capacite) of Integers;
            Pile.Sommet := 0;
        end;

    procedure empiler(Pile:in out T_Pile,v:in Integer) is
    begin
        Pile.som := Pile.som+1
        Pile.data(Pile.som) := v
    end

    etc...







Afficher des entiers

with pile
use pile
procedure Affichage_avec_pile(Fe:in Integer) is
 nb : Integer
 P : pile
 begin

 --Afficher le signe - si fe est négatif
if fe<0 do
    ecrire('-')
sinon
    null;
end

-- empiler les digits à partir des unitées(?)
init(P)
nb<-Fe
 Tant que nb/10 != 0
    Empiler(P,nb%10);
    nb<-nb/10
 FinTQ

-- afficher les digits empilés
 TQ(NON(estVide(P)))
    Afficher(sommet(P))
    depiler(P)
 FinTQ


fin Affichage_avec_pile;

On peut déplacer ce code dans un package affichage(différent de celui de pile, car pas même sujet)